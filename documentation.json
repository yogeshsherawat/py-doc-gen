{"MongoDBManager.get_client": "/**\n* This function is responsible for returning a MongoDB client instance.\n* If the client instance does not exist, it creates a new one using the provided connection string.\n* \n* @input None\n* \n* @output MongoDB client instance or None if connection fails\n*/", "MongoDBManager.get_db": "/**\n* This function is used to get a specific database from MongoDB.\n* If the database does not exist, it will return the default database 'coding_bros'.\n* \n* @param {string} db_name - The name of the database to retrieve (default is 'cb' for coding_bros).\n* \n* @returns {pymongo.database.Database} - The specified database from MongoDB.\n*/", "MongoDBManager.get_collection": "'''\nFunction: get_collection\n\nDescription:\nThis function is used to get a specific collection from the MongoDB database.\n\nInputs:\n- collection_name: A string representing the name of the collection to retrieve.\n- db_name: A string representing the name of the database to connect to. Default value is 'cb'.\n\nOutputs:\n- collection: A pymongo.collection.Collection object representing the specified collection from the database.\n'''", "MongoDBManager.get_collection_by_name": "/**\n * This static method retrieves a collection by its name from the MongoDB database.\n * If the collection name is not provided, it returns None.\n * \n * @param collection_name - The name of the collection to retrieve.\n * \n * @return The collection from the MongoDB database with the given name.\n */", "UserDAO.insert_user": "'''\nThis function is used to insert a new user into the database.\n\nInputs:\n- username: a string representing the username of the user\n- full_name: a string representing the full name of the user\n- email: a string representing the email address of the user\n- hashed_password: a string representing the hashed password of the user\n- disabled: a boolean indicating whether the user is disabled or not\n\nOutputs:\n- Returns a dictionary containing the user information that was inserted into the database, including the generated '_id' field.\n'''", "UserDAO.get_user_by_username": "/**\n* This function retrieves a user from the database based on the provided username.\n*\n* @param {string} username - The username of the user to retrieve.\n*\n* @returns {object} - The user object retrieved from the database that matches the provided username.\n*/", "UserDAO.get_user_by_email": "/**\n* This function retrieves a user from the database based on the provided email address.\n* \n* @param {string} email - The email address of the user to retrieve.\n* @returns {object} - The user object retrieved from the database, or null if user is not found.\n*/", "UserDAO.update_user_otp": "/**\n* This static method is responsible for updating the OTP (One Time Password) for a user in the database.\n* It retrieves the user information by the provided email using the get_user_by_email method, updates the OTP field with the new OTP,\n* and then updates the user information in the database.\n* @param {string} email - The email address of the user for whom the OTP needs to be updated.\n* @param {string} otp - The new OTP that needs to be set for the user.\n* @returns {void}\n*/", "UserDAO.get_or_create_user": "/**\n* This function either retrieves an existing user by email from the database \n* or creates a new user if no user with the given email exists.\n* \n* @param email: The email of the user to be retrieved or created.\n* \n* @return user: The user object either retrieved from the database or newly created.\n*/\nstaticmethod def get_or_create_user(email=None):\n    user = UserDAO.get_user_by_email(email)\n    if not user:\n        user = UserDAO.insert_user(email, '', PasswordHelper.hash_password(email), '', False)\n    return user\n*/", "CacheManager.get": "'''\nDocumentation for get function:\n\nThis static method is used to retrieve a value from the cache based on the provided key. It checks if the document with the given key exists in the cache collection and if it has not expired. If the document is found and has not expired, it returns the corresponding value.\n\nInputs:\n- key: The key used to retrieve the value from the cache.\n\nOutputs:\n- If a valid document is found in the cache collection with the given key and it has not expired, the function returns the value associated with that key. Otherwise, it returns None.\n'''", "CacheManager.set": "/**\n * This function sets a key-value pair in the cache with a specified timeout.\n * It updates the cache with the provided key and value, along with an expiration time calculated based on the timeout.\n * If the key already exists in the cache, it updates the existing key-value pair; otherwise, it inserts a new key-value pair.\n * \n * @param {string} key - The key for the key-value pair to be set in the cache.\n * @param {any} value - The value to be associated with the key in the cache.\n * @param {number} timeout - The time in seconds after which the key-value pair should expire in the cache.\n * \n * @returns {void}\n */", "CacheManager.delete": "'''\nFunction: delete\n\nDescription:\nThis static method is used to delete a document from the cache collection based on the provided key.\n\nInputs:\n- key: A string representing the key of the document to be deleted from the cache collection.\n\nOutputs:\nThis function does not return any value but deletes the document from the cache collection based on the provided key.\n'''", "TestPasswordHelper.test_hash_password": "\"\"\"\n- This function is used to test if a password is hashed properly.\n- The function takes no input parameters.\n- The function does not return any output. It uses the assertNotEqual method to check if the original password is not equal to the hashed password.\n\"\"\"", "TestPasswordHelper.test_verify_password": "```markdown\n# Documentation for test_verify_password function\n\n- Function: test_verify_password\n\n## Description:\nThis function is used to test the functionality of verifying a hashed password against the original password.\n\n## Inputs:\n- No external inputs are required for this function.\n\n## Outputs:\n- The function does not return any output. It performs assertions using the assertTrue and assertFalse methods to check the verification of passwords.\n```", "TestPasswordHelper.test_verify_otp": "'''\nDocumentation for test_verify_otp function:\n\n- Functionality:\n    This function is used to test the OTP verification logic by verifying if the user-provided OTP matches the OTP stored in the database.\n\n- Inputs:\n    The function takes two input parameters:\n    1. user_otp (string): The OTP provided by the user for verification.\n    2. db_otp (string): The OTP stored in the database for comparison.\n\n- Outputs:\n    The function returns a boolean value based on the comparison of the user-provided OTP and the database OTP. \n    - True: If the user-provided OTP matches the database OTP.\n    - False: If the user-provided OTP does not match the database OTP or if an exception occurs during the comparison.\n\n'''", "TestPasswordHelper.test_generate_otp": "'''\nFunction: test_generate_otp\n\nDescription:\nThis function is used to test the OTP generation functionality to ensure that the generated OTP is within the expected range.\n\nInputs:\n- No inputs required as it is a test function.\n\nOutputs:\n- The function generates an OTP using the generate_otp function from the PasswordHelper class.\n- The expected OTP value is 123456.\n- The function asserts that the generated OTP is equal to 123456.\n'''", "PriorityQueue.__init__": "'''\nDocumentation for main code:\n\nFunction: __init__\n\nDescription:\nThis function is the constructor method for a heap data structure. It initializes the priority queue and sets the type of heap as either min heap or max heap based on the input parameter.\n\nInputs:\n- heap_type: a string indicating the type of heap to create. It can be either 'min' for a min heap or 'max' for a max heap. Default value is 'min'.\n\nOutputs:\nNone\n'''", "PriorityQueue.add": "'''\nFunction: add\n\nDescription:\nThis function is used to add an object with a specified priority to the priority queue. \nThe function takes into consideration the type of heap (max or min) and adjusts the priority accordingly before adding the object to the priority queue.\n\nInputs:\n- priority: An integer representing the priority of the object to be added.\n- object: The object to be added to the priority queue.\n\nOutputs:\nThis function does not return any output explicitly. It adds the object with the specified priority to the priority queue.\n'''", "PriorityQueue.pop": "'''\nDocumentation for pop function:\n\nThis function removes and returns the smallest element from the priority queue.\n\nInputs:\n    - self: the priority queue object from which the smallest element needs to be removed.\n\nOutputs:\n    - item: the smallest element that was removed from the priority queue.\n'''", "PriorityQueue.length": "'''\nFunction: length\n\nDescription:\nThis function calculates the length of the priority queue.\n\nInputs:\n- self: The priority queue object for which the length needs to be calculated.\n\nOutputs:\n- The length of the priority queue (number of elements in the priority queue).\n'''", "Solution.dijkstra": "'''\nFunction: dijkstra\n\nDescription:\nThis function implements Dijkstra's algorithm to find the shortest path from a source node to all other nodes in a weighted graph.\n\nInputs:\n- V: The number of vertices in the graph\n- adj: The adjacency list representing the graph where adj[i] contains the neighbors of node i along with their edge weights\n- S: The source node from which the shortest paths are calculated\n\nOutputs:\n- ans: A list containing the shortest distance from the source node to all other nodes in the graph\n'''", "UnionFind.__init__": "'''\nFunction: __init__\n\nDescription:\nThis function initializes a data structure to represent a disjoint set forest. It creates a list to store the root of each element and another list to store the rank of each element. It also stores the total number of elements in the data structure.\n\nInputs:\n- n: An integer representing the total number of elements in the disjoint set forest.\n\nOutputs:\nThis function does not return any output explicitly, but it initializes the data structure with the given number of elements and their corresponding ranks.\n'''", "UnionFind.find": "'''\nFunction: find\n\nDescription:\nThis function is used to find the root of a given vertex in a disjoint set data structure. It implements the path compression technique to optimize the search operation.\n\nInputs:\n- vertex: The vertex for which the root needs to be found.\n\nOutputs:\n- Returns the root of the input vertex.\n'''", "UnionFind.union": "'''\nDocumentation for union function:\n\nDescription:\nThis function is used to merge two sets by connecting the roots of the sets to each other. It performs union operation on two given vertices by finding their respective roots and updating the root of one set to the root of the other set based on their ranks.\n\nInputs:\n- vertex_x: The first vertex for which union operation needs to be performed.\n- vertex_y: The second vertex for which union operation needs to be performed.\n\nOutputs:\nThis function does not return any output. It updates the root of one set to the root of the other set based on their ranks.\n'''", "UnionFind.connected": "'''\nDocumentation for connected function:\n\n- This function checks if two vertices are connected in the graph.\n  \nInputs:\n- vertex_x: a vertex in the graph\n- vertex_y: another vertex in the graph\n\nOutputs:\n- Returns True if vertex_x and vertex_y are connected, False otherwise\n'''", "UnionFind.find_number_of_different_components": "'''\nDocumentation for main code: find_number_of_different_components\n\nThis function calculates the number of different components in a given data structure.\n\nInputs:\n- self: the instance of the class containing the data structure\n- self.n: the total number of elements in the data structure\n- self.find(i): a helper function that finds the root of the component containing element i\n\nOutputs:\n- The function returns an integer representing the number of different components in the data structure.\n'''", "Solution.distanceLimitedPathsExist": "'''\nFunction: distanceLimitedPathsExist\n\nDescription:\nThis function determines if there exists a path between two nodes in a graph such that the sum of the weights of the edges on the path is less than a given limit.\n\nInputs:\n- n: An integer representing the number of nodes in the graph.\n- edgeList: A list of tuples where each tuple contains the weight of the edge, the starting node, and the ending node.\n- queries: A list of tuples where each tuple contains the weight limit, the starting node, the ending node, and an index.\n\nOutputs:\n- ans: A list of boolean values where each value corresponds to whether there exists a path between the starting and ending nodes within the weight limit for the corresponding query.\n'''", "Solution.maxNumEdgesToRemove": "```markdown\n## maxNumEdgesToRemove Function\n\nThis function calculates the maximum number of edges that can be removed from a graph to make it traversable for both Alice and Bob.\n\n### Inputs:\n- n: an integer representing the number of nodes in the graph\n- edges: a list of lists where each inner list represents an edge in the graph. Each inner list contains three elements: the type of edge (1, 2, or 3) and the two nodes connected by the edge.\n\n### Outputs:\n- Returns an integer representing the maximum number of edges that can be removed to make the graph traversable for both Alice and Bob. If it is not possible to make the graph traversable, it returns -1.\n\n### Algorithm:\n1. Initialize two UnionFind data structures for Alice and Bob.\n2. Iterate through the edges:\n   - If the edge is of type 3, union the nodes in both UnionFind structures and increment the edges_required count.\n   - If the edge is of type 1 or 2, union the nodes in the respective UnionFind structure and increment the edges_required count.\n3. Define a helper function `is_graph_traversable` to check if the graph is traversable for a given UnionFind structure.\n4. Check if the graph is traversable for both Alice and Bob using the `is_graph_traversable` function.\n5. Return the maximum number of edges that can be removed to make the graph traversable for both Alice and Bob.\n\n```  ", "Solution.swimInWater": "'''\nDocumentation for swimInWater function:\n\nThis function calculates the minimum possible value of the maximum element on a path from the top-left cell to the bottom-right cell of a grid.\n\nInputs:\n- grid: a square grid (2D list) of size n x n (where n is the number of rows and columns in the grid). Each cell in the grid contains a non-negative integer representing the elevation at that point.\n\nOutputs:\n- Returns an integer representing the minimum possible value of the maximum element on a path from the top-left cell to the bottom-right cell. If no such path exists, it returns -1.\n\nAlgorithm:\n1. Create a list 'edges' to store all possible edges between adjacent cells in the grid.\n2. Iterate through each cell in the grid and check for adjacent cells to create edges with their maximum elevation.\n3. Sort the edges based on their maximum elevation.\n4. Initialize 'src' as the elevation of the top-left cell and 'dst' as the elevation of the bottom-right cell.\n5. Create a UnionFind data structure with the number of edges.\n6. Iterate through the sorted edges and union the cells they connect.\n7. Check if the top-left cell and bottom-right cell are connected in the UnionFind data structure. If they are connected, return the maximum elevation of the current edge.\n8. If no path is found, return -1.\n\nNote: The UnionFind class is assumed to be implemented elsewhere in the codebase.\n\n'''", "Solution.removeStones": "'''\n# Function: removeStones\nThis function calculates the minimum number of stones to remove in order to make all stones non-overlapping.\n\n## Inputs:\n- self: reference to the current instance of the class\n- stones: a list of lists where each sublist contains the x and y coordinates of a stone\n\n## Outputs:\n- Returns an integer representing the minimum number of stones to remove\n\n## Steps:\n1. Initialize a UnionFind data structure with the number of stones.\n2. Iterate through all pairs of stones and if they share the same row or column, union them.\n3. Count the number of connected components after union operations.\n4. Return the count of stones minus the number of connected components.\n\n'''", "Solution.findCircleNum": "'''\nDocumentation for findCircleNum function:\n\nThis function calculates the number of connected components in a given graph represented by the isConnected matrix using Union-Find algorithm.\n\nInputs:\nself: reference to the current instance of the class\nisConnected: a 2D matrix representing the graph where isConnected[i][j] is 1 if there is a direct connection between nodes i and j, and 0 otherwise\n\nOutput:\nReturns the number of different connected components in the graph\n\nUnionFind class:\n- __init__: initializes the UnionFind data structure with an array to store the root of each element and another array to store the rank of each element\n- find: finds the root of the input vertex using path compression technique\n- union: performs union operation on two input vertices by updating their roots based on rank\n- connected: checks if two input vertices are connected or not\n- find_number_of_different_components: returns the number of unique roots in the UnionFind data structure\n\n'''", "Solution.areConnected": "```markdown\n# areConnected Function\n\nThis function determines if two vertices are connected in a graph using the Union-Find algorithm.\n\n## Inputs\n- n: an integer representing the number of vertices in the graph\n- threshold: an integer representing the threshold value\n- queries: a list of tuples representing the queries to check if two vertices are connected\n\n## Outputs\n- ans: a list of boolean values indicating whether the vertices in the queries are connected or not\n```", "AudioHelper.execute_ffmpeg_command": "'''\nDocumentation for execute_ffmpeg_command function:\n\n- This function is used to execute an ffmpeg command with the provided filter.\n- Inputs:\n    - command_filter: A string representing the filter to be applied in the ffmpeg command.\n- Outputs:\n    - output: A string containing the output of the executed ffmpeg command.\n'''", "AudioHelper.get_audio_loudness_information": "/**\n* Get volume information from an audio file using FFmpeg.\n* This function takes the path of an audio file as input and uses FFmpeg to extract volume information such as integrated loudness, true peak, LRA, threshold, normalization type, and target offset.\n* @param audio_file_path: The file path of the audio file for which volume information needs to be extracted.\n* @return loudness_info: A dictionary containing the extracted volume information including input integrated loudness, input true peak, input LRA, input threshold, output integrated loudness, output true peak, output LRA, output threshold, normalization type, and target offset.\n*/", "AudioHelper.normalize_audio_loudness": "```markdown\n## normalize_audio_loudness function\n\nThis function is used to get volume information from an audio file using FFmpeg loudnorm filter.\n\n### Inputs:\n- input_path: Path to the input audio file.\n- output_path: Path to save the output audio file.\n- input_integrated: Measured Integrated Loudness (LUFS) of the input audio.\n- input_true_peak: Measured True Peak (dBTP) of the input audio.\n- input_lra: Measured Loudness Range (LU) of the input audio.\n- input_threshold: Measured Threshold (LUFS) of the input audio.\n- offset: Target offset value for loudness normalization.\n- linear: Boolean flag indicating whether to use linear mode for loudness normalization (default is True).\n- print_format: Format for printing the loudness normalization information (default is 'summary').\n\n### Outputs:\n- loudness_info: A dictionary containing the following loudness information:\n  - input_integrated: Measured Integrated Loudness (LUFS) of the input audio.\n  - input_true_peak: Measured True Peak (dBTP) of the input audio.\n  - input_lra: Measured Loudness Range (LU) of the input audio.\n  - input_threshold: Measured Threshold (LUFS) of the input audio.\n  - output_integrated: Output Integrated Loudness (LUFS) after normalization.\n  - output_true_peak: Output True Peak (dBTP) after normalization.\n  - output_lra: Output Loudness Range (LU) after normalization.\n  - output_threshold: Output Threshold (LUFS) after normalization.\n  - normalization_type: Type of normalization applied.\n  - target_offset: Target offset value used for normalization.\n\n```  ", "AudioHelper.is_audio_normalized": "'''\nFunction: is_audio_normalized\n\nDescription:\nThis static method checks if the input audio is normalized based on the integrated loudness range.\n\nInputs:\n- input_integrated: A numeric value representing the integrated loudness of the audio.\n\nOutputs:\n- Returns a boolean value indicating whether the input audio is normalized (True) or not (False).\n'''", "FilePickerApp.__init__": "'''\nDocumentation for main code:\n\nThis code initializes an object and sets the selected file path to None. It then calls the init_ui method to initialize the user interface.\n\nInputs: \n    No inputs are required for this __init__ method.\n\nOutputs:\n    No outputs are returned by this __init__ method.\n'''", "FilePickerApp.init_ui": "'''\nFunction init_ui:\n- This function initializes the user interface for the PyQt File Picker Example.\n- It sets up the window title, creates buttons to open a file picker and normalize the selected file, and connects the button clicks to respective functions.\n\nInputs: \n- self: The instance of the class where this function is being called.\n\nOutputs:\n- None\n'''", "FilePickerApp.on_pick_file_button_click": "'''\nFunction: on_pick_file_button_click\n\nDescription:\nThis function is triggered when the user clicks on the \"Pick File\" button. It opens a file dialog window for the user to select a file, and upon selection, it sets the selected file path, updates a label with the selected file path, and enables the \"Normalize\" button.\n\nInputs:\n- self: The reference to the current instance of the class.\n  \nOutputs:\n- None\n'''", "FilePickerApp.on_normalize_button_click": "'''\nFunction: on_normalize_button_click\n\nDescription:\nThis function is triggered when the normalize button is clicked. It renames the selected file by replacing spaces with underscores and moves it to the Downloads folder.\n\nInputs:\n- self: The instance of the class where this function is defined. It contains information about the selected file path.\n\nOutputs:\n- Renamed file: The selected file is renamed with spaces replaced by underscores and moved to the Downloads folder. The new file path is displayed in a label.\n'''", "CircuitBreaker.__init__": "'''\nFunction: __init__\n\nDescription:\nThis function initializes an instance of a service monitoring class with default values for failure count, failure threshold, reset timeout, last failure time, and service name.\n\nInputs:\n- service_name: a string representing the name of the service\n\nOutputs:\n- None\n'''", "CircuitBreaker.get_state": "'''\nFunction: get_state\n\nDescription:\nThis function determines the current state of the system based on the failure count, failure threshold, last failure time, and reset timeout. It checks if the system should be in a 'CLOSED' state or an 'OPEN' state based on the conditions.\n\nInputs:\n- self: The object instance on which the method is called. It contains attributes such as failure_count, failure_threshold, last_failure_time, reset_timeout.\n\nOutputs:\n- Returns a string indicating the current state of the system. It can be either 'CLOSED' if the system has recovered from failures or 'OPEN' if the system is still in a failed state.\n'''", "CircuitBreaker.reset": "'''\nFunction: reset\n\nDescription:\nThis function resets the failure count and last failure time to their initial values.\n\nInputs:\n- self: the object itself\n\nOutputs:\nThis function does not return any value.\n'''", "CircuitBreaker.increment_failure_count": "'''\nFunction: increment_failure_count\n\nDescription:\n    This function is used to increment the failure count by 1 and update the last failure time to the current time.\n\nInputs:\n    - self: The instance of the class on which this method is called.\n\nOutputs:\n    This function does not return any value. It updates the failure_count and last_failure_time attributes of the class instance.\n'''", "CircuitBreaker.execute_action": "'''\nFunction: execute_action\n\nDescription:\nThis function is used to execute a specific action based on the current state of the service. If the state is 'OPEN', it returns the fallback response from the service name. Otherwise, it tries to execute the action of the service. If an exception occurs during the execution, it increments the failure count and returns the fallback response from the service.\n\nInputs:\n- self: The instance of the class containing the execute_action method.\n\nOutputs:\n- Fallback response from the service name if the state is 'OPEN'.\n- Action execution result from the service if the state is not 'OPEN' and no exception occurs.\n- Fallback response from the service if an exception occurs during the action execution.\n'''", "UtilsHelper.is_production": "'''\nDocumentation for is_production function:\n\nThis function is used to determine if the application is running in a production environment based on the value of the environment variable 'IS_TESTING'.\n\nInputs:\n- No direct inputs are required for this function. It reads the value of the 'IS_TESTING' environment variable.\n\nOutputs:\n- The function returns a boolean value indicating whether the application is in a production environment (True) or not (False).\n'''", "FileHelper.save_text_in_file": "'''\nFunction: save_text_in_file\n\nDescription:\nThis static method is used to save the given text into a file specified by the output_file_path.\n\nInputs:\n1. text: The text that needs to be saved in the file. (Type: str)\n2. output_file_path: The file path where the text will be saved. (Type: str)\n\nOutputs:\nThis function does not return any value. It simply writes the given text to the specified file.\n'''", "FileHelper.load_json_data_from_json_file": "'''\nDocumentation for load_json_data_from_json_file function:\n\nThis function loads JSON data from a JSON file.\n\nInputs:\n- filepath: A string representing the file path of the JSON file from which data needs to be loaded.\n\nOutputs:\n- json_data: A dictionary containing the loaded JSON data from the file.\n'''", "FileHelper.dump_json_data_to_json_file": "/**\n* This function dumps JSON data to a JSON file.\n* It takes the input data in JSON format and the filepath where the data needs to be stored.\n* @param data: The JSON data that needs to be dumped to the file.\n* @param filepath: The file path where the JSON data will be stored.\n* @return: This function does not return anything.\n*/", "FileHelper.download_json_data_from_raw_github_url": "'''\nDocumentation for download_json_data_from_raw_github_url function:\n\nThis function downloads JSON data from a raw GitHub URL, decodes it, and loads it into a JSON object.\n\nInputs:\n    - No inputs required explicitly in the function definition. \n    - The URL of the JSON file is hardcoded within the function.\n\nOutputs:\n    - json_object: A JSON object containing the data fetched from the raw GitHub URL.\n\nNote:\n    - This function uses the requests library to fetch data from the specified URL.\n    - The fetched data is then decoded into a utf-8 string and loaded into a JSON object using the json library.\n    - The JSON object is printed and returned as the output of the function.\n'''", "JWTHelper.create_access_token": "/**\n* This function is used to create an access token by encoding the provided data using JWT encoding.\n* The access token will contain an expiration time based on the value of ACCESS_TOKEN_EXPIRE_MINUTES.\n* \n* @param data: A dictionary containing the data to be encoded into the access token.\n* @return: The encoded JWT access token as a string.\n*/", "JWTHelper.verify_token": "'''\nFunction: verify_token\n\nDescription:\nThis function is used to verify a JWT token by decoding it using the provided SECRET_KEY and ALGORITHM. It checks if the token is valid and retrieves the username from the token payload.\n\nInputs:\n- token (str): A JWT token that needs to be verified.\n- credentials_exception: An exception to be raised if the username is not found in the token payload.\n\nOutputs:\n- username (str): The username extracted from the token payload if the token is valid. If the username is not found or the token is invalid, it raises the credentials_exception.\n'''", "EmailHelper.send_email": "/**\n* This function sends an email to the specified receiver with the given subject and content.\n* If no receiver email is provided, it prints a message and returns without sending the email.\n* \n* @param receiver_email The email address of the recipient.\n* @param subject The subject of the email.\n* @param text The plain text content of the email.\n* @param html The HTML content of the email (optional).\n* \n* @return None\n* \n* This function does not return any value but sends an email using the provided parameters.\n*/", "AudioHelper.normalize_audio": "### Documentation for `normalize_audio` function\n\n- **Functionality**: \n    - This function is used to normalize the audio loudness for an episode based on a predefined loudness range.\n\n- **Inputs**:\n    - `audio_file_path`: Path to the audio file that needs to be normalized.\n\n- **Outputs**:\n    - `audio_loudness_output`: Information about the audio loudness obtained from the input audio file.\n    - `is_eligible_for_normalization`: A boolean flag indicating whether the audio file is eligible for normalization.\n    - `normalized_data`: Information about the normalized audio file including integrated loudness, true peak, LRA, threshold, and target offset.", "TimeHelper.get_day_number_of_today_in_year": "'''\nDocumentation for get_day_number_of_today_in_year function:\n\nThis function is used to get the day number of today in the current year.\n\nInputs:\nThis function does not take any input parameters.\n\nOutputs:\nThe output of this function is the day number of today in the current year.\n\nExample:\nget_day_number_of_today_in_year() \n- Output: 150 (if today is the 150th day of the year)\n'''", "LogHelper.log": "/**\n* This function is used to log a message using the logger.\n* @param message - The message to be logged.\n* @return None\n*/", "AuthHelper.authenticate_user": "/**\n* This function is used to authenticate a user by checking if the provided username and password are valid.\n* If the user exists in the database and the provided password matches the hashed password stored in the database, the user is authenticated.\n* @param username: A string representing the username of the user trying to authenticate.\n* @param password: A string representing the password of the user trying to authenticate.\n* @return Returns the user object if authentication is successful, otherwise returns False.\n*/", "AuthHelper.authenticate_user_by_email": "/**\n * This function is used to authenticate a user by email using OTP (One Time Password).\n * It verifies the OTP provided by the user with the OTP stored in the cache and then retrieves or creates a user with the given email.\n * @param email - A string representing the email of the user trying to authenticate.\n * @param otp - A string representing the OTP (One Time Password) provided by the user for authentication.\n * @returns If the OTP provided by the user matches the OTP stored in the cache, it returns the user associated with the given email.\n *          Otherwise, it returns False.\n */", "TextHelper.extract_text_from_srt": "'''\nFunction: extract_text_from_srt\n\nDescription:\nThis static method extracts the text content from a .srt file. It reads the lines from the file, skips lines that contain timing information, and concatenates the non-timing lines to extract the text content.\n\nInputs:\n- srt_path: A string representing the file path of the .srt file from which text needs to be extracted.\n\nOutputs:\n- extracted_text: A string containing the extracted text content from the .srt file.\n'''", "PasswordHelper.hash_password": "'''\nFunction: hash_password\n\nDescription:\nThis function is used to hash the input password using PasswordHelper.pwd_context.\n\nInputs:\n- password: A string representing the password that needs to be hashed.\n\nOutputs:\n- Returns a hashed version of the input password.\n'''", "PasswordHelper.verify_password": "'''\nDocumentation for verify_password function:\n\nThis function is used to verify if a plain text password matches a hashed password.\n\nInputs:\n- plain_password: A string representing the plain text password that needs to be verified.\n- hashed_password: A string representing the hashed password to compare with the plain text password.\n\nOutputs:\n- Returns a boolean value indicating whether the plain text password matches the hashed password.\n'''", "PasswordHelper.verify_otp": "'''\nFunction: verify_otp\n\nDescription:\nThis function is used to verify if the user-provided OTP matches the OTP stored in the database.\n\nInputs:\n- user_otp: A string representing the OTP entered by the user.\n- db_otp: A string representing the OTP stored in the database.\n\nOutputs:\n- Returns a boolean value:\n    - True: If the user-provided OTP matches the OTP stored in the database.\n    - False: If the user-provided OTP does not match the OTP stored in the database or if there is an exception while converting the inputs to integers.\n'''", "PasswordHelper.generate_otp": "'''\nFunction: generate_otp\n\nDescription:\nThis function generates a one-time password (OTP) for user authentication purposes. The OTP is a 6-digit code that can be used for verifying the user's identity.\n\nInputs:\nThis function does not take any input parameters.\n\nOutputs:\n- Returns a 6-digit OTP code as an integer.\n'''", "PieHelper.get_pick_up_line": "'''\nFunction: get_pick_up_line\n\nDescription:\nThis function retrieves a random unused pick-up line from the database and returns it.\n\nInputs:\nNone\n\nOutputs:\n- pick_up_line: A random unused pick-up line retrieved from the database\n'''", "PieHelper.mark_pick_up_line_as_used": "/**\n* This function marks a pick-up line as used in the database.\n* It sets the 'used' flag to True for the specified pick-up line.\n* \n* @param pickup_line - The pick-up line to be marked as used.\n* \n* @return void\n*/", "PieHelper.get_pickup_lines_from_db": "/**\n * This function retrieves pickup lines from a JSON database file.\n * It loads the JSON data from the file specified by the DB_PATH constant in the PieHelper class,\n * extracts the pickup lines from the data, and returns them.\n * \n * @return The pickup lines extracted from the JSON database file.\n */", "PieHelper.get_pie_data_from_db": "'''\nFunction: get_pie_data_from_db\n\nDescription:\nThis function retrieves pie data from a JSON file stored in the database.\n\nInputs:\nNone\n\nOutputs:\n- pie_data: A dictionary containing the pie data retrieved from the JSON file in the database.\n'''", "PieHelper.get_subject": "'''\n        - This function generates a subject line for a request based on the day number and a list of names.\n        \n        - Inputs:\n            - day: an integer representing the day number.\n        \n        - Outputs:\n            - subject: a string representing the subject line for the request.\n'''", "PieHelper.get_day": "'''\nFunction: get_day\n\nDescription:\nThis function retrieves the 'day' data from a JSON file containing pie data.\n\nInputs:\n- No direct inputs required. It indirectly uses the load_json_data_from_json_file function from FileHelper.\n\nOutputs:\n- Returns the 'day' data from the JSON file.\n'''", "PieHelper.set_day": "'''\nFunction set_day(day):\n- This function is used to update the 'day' attribute in the pie data obtained from the database.\n- Inputs:\n    - day: The new day value to be set in the pie data.\n- Outputs:\n    - None\n\n'''", "PieHelper.should_script_run": "'''\nFunction: should_script_run\n\nDescription:\nThis function determines whether a script should run based on the last run time of the script stored in the database. It calculates the time elapsed since the last run and compares it with a threshold to decide if the script should run or not.\n\nInputs:\n- None\n\nOutputs:\n- Boolean value:\n    - True: If the script should run based on the time elapsed since the last run\n    - False: If the script should not run based on the time elapsed since the last run\n'''", "PieHelper.update_last_run_time_of_script": "/**\n * This function updates the last run time of a script in the pie data stored in a JSON file.\n * It retrieves the current timestamp, fetches the pie data from the database, updates the 'script_last_ran' field with the current timestamp,\n * and then saves the updated pie data back to the JSON file.\n * \n * Inputs: None\n * \n * Outputs: None\n */", "PieHelper.get_random_pick_up_line": "/**\n* This function retrieves a random pick-up line from a JSON file containing pick-up lines.\n* \n* Inputs:\n* None\n* \n* Outputs:\n* String: A randomly selected pick-up line from the JSON file.\n*/", "DSAHelper.load_questions": "/**\n* This function loads the questions from a file specified in DSAHelper.file_path\n* and stores them in DSAHelper.questions list.\n* \n* Inputs:\n* This function does not take any inputs directly, but reads the file path from DSAHelper.file_path.\n* \n* Outputs:\n* This function does not return anything. It reads the questions from the file and stores them in DSAHelper.questions list.\n*/", "DSAHelper.get_questions": "'''\nDocumentation for get_questions function:\n\nFunctionality:\nThis static method is used to retrieve the list of questions available in the DSAHelper class. If there are no questions available, it will return a message indicating that there are no questions available.\n\nInputs:\nThis function does not take any inputs.\n\nOutputs:\n- If there are questions available, it will return the list of questions.\n- If there are no questions available, it will return a message 'No questions available.'\n'''", "DSAHelper.get_link_of_question": "'''\n- This function generates a link to a specific question on the LeetCode website.\n- Inputs:\n    - question: a string representing the question number or title.\n- Outputs:\n    - Returns a string that is the URL link to the question on the LeetCode website.\n'''", "DSAHelper.give_random_question": "'''\n- This function is used to retrieve a random question from a list of questions stored in the DSAHelper class.\n- Inputs: This function does not take any inputs.\n- Outputs: \n    - If there are no questions available in the DSAHelper class, it will return the message 'No questions available.'\n    - If there are questions available, it will return a random question selected from the list of questions.\n'''", "DSAHelper.give_random_unsolved_question": "/**\n* This function is used to retrieve a random unsolved question from the available questions in the system.\n* It checks for questions that have not been marked as solved and returns one of those questions randomly.\n* If all questions have been solved, it returns a congratulatory message.\n* \n* @param None\n* \n* @return A random unsolved question from the available questions or a congratulatory message if all questions are solved.\n*/", "DSAHelper.mark_question_as_solved": "/**\n* This function marks a question as solved by updating the frequency of the question in the solved file.\n* If the question does not exist in the list of questions, an exception is raised.\n* Inputs:\n* @param question - The question to be marked as solved.\n* Outputs:\n* The function does not return any output but updates the solved file with the frequency of the solved question.\n*/", "DSAHelper.get_solved_frequencies": "'''\nFunction: get_solved_frequencies\n\nDescription:\n    This function reads a file containing solved questions and their frequencies, and returns a dictionary \n    with the questions as keys and their corresponding frequencies as values.\n\nInputs:\n    There are no direct inputs to this function. It reads the data from a file specified by DSAHelper.solved_file_path.\n\nOutputs:\n    The function returns a dictionary 'frequencies' where:\n        - Key: question (string) - the question that has been solved.\n        - Value: frequency (integer) - the number of times the question has been solved.\n\n    If the file specified by DSAHelper.solved_file_path does not exist, the function returns an empty dictionary.\n\nNote:\n    - The file should be formatted as 'question:frequency' pairs separated by a colon ':'.\n    - If there are multiple entries for the same question, the last entry will overwrite the previous ones.\n'''"}